---
title: Moore-Hodgson Algorithm
type: 'blog'
date: 2022-02-02
published: true
description: 'An attempt to minimize the number of late jobs in a single machine.'
tags: ['Golang', 'Scheduling']
---

I found this algorithm on a book called **Handbook of Scheduling: Algorithms, Models, and Performance Analysis**,
written by James H. Anderson and Joseph Y-T. Leung, which was originally published in 2004.

In the book, I found several algorithms that are suitable for my experiment such as **Kuhn-Munkres**
and **Branch-and-Bound** algorithms.

While reading, I stumbled upon an algorithm called **Moore-Hodgson** which helps us minimize the number
of late jobs given we have too many things to do.

That algorithm reminds me of my experience in the undergraduate program where most students procrastinate
and pill up the work near the due dates.

I realized the algorithm was not complicated, and I gave it a try to implement it in **golang**.

You should know that this implementation is based on
[one of the slides](https://www.win.tue.nl/~wscor/OW/2P450/MooreHodgson.pdf) provided
in a class called [Sequencing and Scheduling](https://www.win.tue.nl/~wscor/OW/2P450/)
at [TU Eindhoven](https://www.tue.nl/en/).

Before we get into the coding part, let's see how this algorithm works.

# Algorithm

Let $d_j$ be the due date of job $j$, $p_j$ be the processing time of job $j$, and $C_j$ be the completion time needed to finish the jobs.

1. Sort the jobs by due date in increasing order.
2. Let **scheduled job** set and the **rejected job** set be empty.
3. Let the completion time to be $C_j = 0$.
4. For $j = 1, \ldots, n$ do
   - Add $j_j$ to the **scheduled job** set.
   - If $C_j + p_j \leq d_j$,
     - Add $j_j$ to the **scheduled job** set.
     - $C_j$ = $C_j + p_j$.
   - If $C_j + p_j > d_j$,
     - Find a job with the largest processing time in the **scheduled job** set, and let it be $d_k$.
     - Remove the job from the **scheduled job** set, and move it to the **rejected job** set.
     - $C_j$ = $C_j + p_j - d_k$.
5. Add the jobs in the **rejected job** set to the **scheduled job** set in order of due date.

# Worked Examples

## Problem 1

Let's say there are several jobs with due dates and their processing times.

|                       |   1   |   2   |   3   |   4   |   5   |
| :-------------------- | :---: | :---: | :---: | :---: | :---: |
| Due Date $d_j$        |   6   |   7   |   8   |   9   |  11   |
| Processing Time $p_j$ |   4   |   3   |   2   |   5   |   6   |

Let's add the completion time needed if we plan to do all the jobs.

|                       |   1   |   2   |   3   |   4   |   5   |
| :-------------------- | :---: | :---: | :---: | :---: | :---: |
| Due Date $d_j$        |   6   |   7   |   8   |   9   |  11   |
| Processing Time $p_j$ |   4   |   3   |   2   |   5   |   6   |
| Completion Time $C_j$ |   4   |   7   |   9   |  14   |  20   |

If we try to go through each job, it takes 20 days finish all tasks.
Meaning that we can only deliver 2 jobs on time, and 3 jobs late.

With **Moore-Hodgson**, we can skip over the tasks that require more processing time and include
tasks that require less processing time. Thus, we can maximize the number of jobs that we can deliver.

Solving the probem above with **Moore-Hodgson**, we then have the following table.

|                       |   1   |   2   |   3   |   4   |   5   |               |
| :-------------------: | :---: | :---: | :---: | :---: | :---: | :-----------: |
| Due Date $d_j$        |   6   |   7   |   8   |   9   |  11   |               |
| Processing Time $p_j$ |   4   |   3   |   2   |   5   |   6   | Rejected Jobs |
| Completion Time $C_j$ |   4   |   -   |   -   |   -   |   -   |       -       |
|                       |   4   |   7   |   -   |   -   |   -   |       -       |
|                       |   4   |   7   |   9   |   -   |   -   |       -       |
|                       |   4   |   7   |  \*   |   -   |   -   | Job 3         |
|                       |   4   |   7   |  \*   |  12   |   -   | Job 3         |
|                       |   4   |   7   |  \*   |  \*   |   -   | Job 3, 4, & 5 |
|                       |   4   |   7   |  \*   |  \*   |  13   | Job 3, 4, & 5 |
|                       |   4   |   7   |  \*   |  \*   |  \*   | Job 3, 4, & 5 |

Let's try another example with more jobs.

## Problem 2

|                       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :-------------------- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Due Date $d_j$        |   6   |   8   |   9   |  11   |  20   |  25   |  28   |  35   |
| Processing Time $p_j$ |   4   |   1   |   6   |   3   |   6   |   8   |   7   |  10   |

Adding the completion time, we have the following output.

|                       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :-------------------- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Due Date $d_j$        |   6   |   8   |   9   |  11   |  20   |  25   |  28   |  35   |
| Processing Time $p_j$ |   4   |   1   |   6   |   3   |   6   |   8   |   7   |  10   |
| Completion Time $C_j$ |   4   |   5   |  11   |  14   |  20   |  28   |  35   |  45   |

It takes 45 days in order to complete all jobs.
Meaning that, we can only deliver 2 jobs, and 6 jobs late.
Imagine telling your boss that kind of news.

Let's see how many jobs we can optimize the numbers of jobs that we can deliver on time.
Solving the probem above with **Moore-Hodgson**, we then have the following table.

|                       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |               |
| :-------------------- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :-----------: |
| Due Date $d_j$        |   6   |   8   |   9   |  11   |  20   |  25   |  28   |  35   |               |
| Processing Time $p_j$ |   4   |   1   |   6   |   3   |   6   |   8   |   7   |  10   | Rejected Jobs |
| Completion Time $C_j$ |   4   |   -   |   -   |   -   |   -   |   -   |   -   |   -   | -             |
|                       |   4   |   5   |   -   |   -   |   -   |   -   |   -   |   -   | -             |
|                       |   4   |   5   |  11   |   -   |   -   |   -   |   -   |   -   | -             |
|                       |   4   |   5   |  \*   |   -   |   -   |   -   |   -   |   -   | Job 3         |
|                       |   4   |   5   |  \*   |   8   |   -   |   -   |   -   |   -   | Job 3         |
|                       |   4   |   5   |  \*   |   8   |   -   |   -   |   -   |   -   | Job 3         |
|                       |   4   |   5   |  \*   |   8   |  14   |   -   |   -   |   -   | Job 3         |
|                       |   4   |   5   |  \*   |   8   |  14   |  22   |   -   |   -   | Job 3         |
|                       |   4   |   5   |  \*   |   8   |  14   |  22   |  29   |   -   | Job 3         |
|                       |   4   |   5   |  \*   |   8   |  14   |  \*   |  29   |   -   | Job 3 & Job 6 |
|                       |   4   |   5   |  \*   |   8   |  14   |  \*   |  29   |  31   | Job 3 & Job 6 |

Hence with the help of the algorithm, we can have 6 jobs delivered on time and 2 jobs late.
It doesn't sound bad at all.

# Coding

In this project, We will implement this algorithm in **golang**.

First, we need a job master to deal with all the jobs that we have.

```go
type JobMaster struct {
	initialJobs   []Job
	scheduledJobs []Job
	remainingJobs []Job
	lastJobID     int
}

type Job struct {
	id             int
	dueDate        int
	processingTime int
}
```

The job master's responsibility is to keep track of all jobs and to provide each job with a unique ID as soon as it's added in the list.

I have two arrays to store jobs. `scheduledJobs` is where we store the jobs that we intend to do,
and `remainingJobs` is a list of jobs that we have to sacrifice.

```go{11-13}
func main() {
    var master JobMaster
    jobs := [][]int{
        {6, 4},
        {7, 3},
        {8, 2},
        {9, 5},
        {11, 6},
    }

    for _, job := range jobs {
        master.AddJob(job[0], job[1])
    }

    master.AssignJobs()

    scheduledJobs := master.scheduledJobs
    sort.Sort(Jobs(master.remainingJobs))

    endResult := append(scheduledJobs, master.remainingJobs...)

	fmt.Println("Scheduled jobs are", master.scheduledJobs)
	fmt.Println("Remaining jobs are", master.remainingJobs)
	fmt.Println("All the scheduled jobs are", endResult)
}
```

As soon as a job is seen by the job master, a unique ID is assigned to it.
This process is done in line 11-13.
